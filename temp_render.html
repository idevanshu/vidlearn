<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>p5.js Animation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ccapture.js@1.1.0/build/CCapture.all.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: black;
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <script>
      function setup() {
  createCanvas(800, 600);
  frameRate(60);
  noLoop();
  
  // Initialize animation
  startAnimation();
}

let startTime = 0;
let duration = 4000; // 4 seconds
let animationStarted = false;

function startAnimation() {
  startTime = millis();
  animationStarted = true;
  loop();
}

function draw() {
  background(0);
  
  if (!animationStarted) return;
  
  let elapsedTime = millis() - startTime;
  let progress = constrain(elapsedTime / duration, 0, 1);
  
  // Stop animation when complete
  if (progress >= 1) {
    noLoop();
  }
  
  // Draw the scene
  drawFiberScene(progress);
}

function drawFiberScene(progress) {
  push();
  // Set up general styling
  noFill();
  strokeWeight(3);
  
  // Draw fiber optic cable path
  drawFiberPath(progress);
  
  // Draw light beam
  drawLightBeam(progress);
  
  // Draw internet symbols at the end
  if (progress > 0.7) {
    drawInternetSymbols(progress);
  }
  
  // Draw obstacles and interference
  drawObstacles(progress);
  
  // Draw labels
  drawLabels(progress);
  pop();
}

function drawFiberPath(progress) {
  // Draw the fiber cable
  stroke(30, 150, 200, 200);
  strokeWeight(12);
  let pathLength = 700 * min(1, progress * 1.2);
  line(50, 300, 50 + pathLength, 300);
  
  // Cable cladding/outline
  stroke(100, 200, 255, 100);
  strokeWeight(16);
  line(50, 300, 50 + pathLength, 300);
}

function drawLightBeam(progress) {
  let beamPos = 50 + min(700, progress * 2.5 * 700);
  
  // Bright central beam
  for (let i = 0; i < 5; i++) {
    let alpha = 255 - i * 50;
    stroke(255, 255, 200, alpha);
    strokeWeight(3 - i * 0.5);
    
    // Calculate beam path with slight oscillation but always progressing
    let baseY = 300;
    let amplitude = 0; // Start with no oscillation
    
    // After the first obstacle (25% progress), add slight oscillation
    if (beamPos > 250) {
      amplitude = 2;
    }
    
    // After the second obstacle (50% progress), slightly more oscillation but quickly stabilizes
    if (beamPos > 450) {
      amplitude = 4 * (1 - min(1, (beamPos - 450) / 100)); // Oscillation decreases as beam progresses
    }
    
    // Draw the main light beam
    beginShape();
    for (let x = 50; x < beamPos; x += 5) {
      let offset = sin((x - 50) * 0.1) * amplitude;
      vertex(x, baseY + offset);
    }
    endShape();
    
    // Draw light particles following the beam
    if (progress > 0.2) {
      drawLightParticles(progress, amplitude, baseY);
    }
  }
  
  // Glow effect at beam head
  drawBeamHead(beamPos, 300);
}

function drawBeamHead(x, y) {
  // Bright center
  fill(255, 255, 200);
  noStroke();
  ellipse(x, y, 10, 10);
  
  // Outer glow
  for (let i = 0; i < 4; i++) {
    fill(255, 255, 200, 80 - i * 20);
    ellipse(x, y, 14 + i * 5, 14 + i * 5);
  }
}

function drawLightParticles(progress, amplitude, baseY) {
  noStroke();
  
  // Number of particles increases as animation progresses
  let particleCount = int(progress * 40);
  
  for (let i = 0; i < particleCount; i++) {
    let x = 50 + (i / particleCount) * 700 * min(1, progress * 1.5);
    let offset = sin((x - 50) * 0.1) * amplitude;
    let y = baseY + offset;
    
    // Particle flicker effect
    let flicker = sin(frameCount * 0.1 + i * 0.5) * 0.5 + 0.5;
    
    fill(255, 255, 200, 150 * flicker);
    ellipse(x, y, 3, 3);
  }
}

function drawObstacles(progress) {
  // First obstacle (wireless interference)
  if (progress > 0.25) {
    let alpha = constrain(map(progress, 0.25, 0.35, 0, 255), 0, 255);
    
    // Wireless waves that the beam passes through
    stroke(255, 100, 80, alpha);
    strokeWeight(1);
    
    for (let i = 0; i < 3; i++) {
      let waveY = 300 - 50 + i * 50;
      let waveHeight = 100 - i * 20;
      
      beginShape();
      for (let x = 200; x < 300; x += 5) {
        let y = waveY + sin((x - 200) * 0.1 + frameCount * 0.05) * waveHeight * 0.5;
        vertex(x, y);
      }
      endShape();
    }
    
    // Show the beam passing through unaffected
    if (progress > 0.3) {
      let fadeOut = constrain(map(progress, 0.3, 0.4, 1, 0), 0, 1);
      stroke(255, 100, 80, alpha * fadeOut);
      
      // Wireless interference fades out as the beam passes through reliably
      for (let i = 0; i < 3; i++) {
        let waveY = 300 - 50 + i * 50;
        let waveHeight = 100 - i * 20;
        
        beginShape();
        for (let x = 200; x < 300; x += 5) {
          let y = waveY + sin((x - 200) * 0.1 + frameCount * 0.05) * waveHeight * 0.5 * fadeOut;
          vertex(x, y);
        }
        endShape();
      }
    }
  }
  
  // Second obstacle (physical interference)
  if (progress > 0.5) {
    let alpha = constrain(map(progress, 0.5, 0.6, 0, 255), 0, 255);
    
    // Physical obstacle
    fill(120, 120, 120, alpha);
    noStroke();
    rect(400, 270, 30, 60, 5);
    
    // The beam maintains strength as it passes through/around
    if (progress > 0.55) {
      let fadeOut = constrain(map(progress, 0.55, 0.65, 1, 0), 0, 1);
      fill(120, 120, 120, alpha * fadeOut);
      rect(400, 270, 30, 60, 5);
    }
  }
}

function drawInternetSymbols(progress) {
  let alpha = constrain(map(progress, 0.7, 0.9, 0, 255), 0, 255);
  
  push();
  translate(700, 300);
  
  // Show connection reliability with cloud/server icon
  fill(200, 230, 255, alpha);
  noStroke();
  
  // Cloud shape
  ellipse(-10, -10, 40, 30);
  ellipse(10, -15, 35, 25);
  ellipse(20, -5, 30, 30);
  ellipse(0, 0, 50, 35);
  
  // Data packets flowing
  if (progress > 0.8) {
    let packetAlpha = constrain(map(progress, 0.8, 0.9, 0, 255), 0, 255);
    
    for (let i = 0; i < 4; i++) {
      let offset = (frameCount * 3 + i * 20) % 100;
      let x = -offset - 20;
      
      fill(255, 255, 200, packetAlpha);
      rect(x, 0, 10, 5, 2);
    }
  }
  
  pop();
}

function drawLabels(progress) {
  // Title appears first
  if (progress > 0.1) {
    let titleAlpha = constrain(map(progress, 0.1, 0.2, 0, 255), 0, 255);
    fill(255, titleAlpha);
    textSize(28);
    textAlign(CENTER);
    text("Fiber Internet Connection", width/2, 100);
  }
  
  // "Reliable Connection" label appears after beam passes first obstacle
  if (progress > 0.4) {
    let reliableAlpha = constrain(map(progress, 0.4, 0.5, 0, 255), 0, 255);
    fill(255, reliableAlpha);
    textSize(20);
    textAlign(CENTER);
    text("Reliable Connection", width/2, 150);
  }
  
  // "Minimal Interference" label appears after beam passes second obstacle
  if (progress > 0.65) {
    let minimalAlpha = constrain(map(progress, 0.65, 0.75, 0, 255), 0, 255);
    fill(255, minimalAlpha);
    textSize(20);
    textAlign(CENTER);
    text("Minimal Interference", width/2, 180);
  }
}
    </script>
  </body>
</html>